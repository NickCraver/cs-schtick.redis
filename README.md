# Schyntax.RedisLock

[![NuGet version](https://badge.fury.io/nu/Schyntax.RedisLock.svg)](http://badge.fury.io/nu/Schyntax.RedisLock)
[![Build status](https://ci.appveyor.com/api/projects/status/onocaanycxgkuc94/branch/master?svg=true)](https://ci.appveyor.com/project/bretcope/cs-schyntax-redislock/branch/master)

Uses Redis to provide a distributed lock so that for each iteration of a task, the callback will only be called on one server.

# Basic Usage

### Task Locking

To lock a task so that it only runs on one server, use the `Wrap()` on the intended callback for the task:

```csharp
var schtick = new Schtick();
var redis = ConnectionMultiplexer.Connect("localhost:6379");
var wrapper = new RedisSchtickWrapper(() => redis.GetDatabase());

schtick.AddAsyncTask("unique-task-name", "min(*)", wrapper.Wrap((task, timeIntendedToRun) =>
{
	// your callback code here
}));
```

Since the lambda generated by `RedisSchtickWrapper.Wrap()` is async, we always add it using `Schtick.AddAsyncTask()`. If the inner callback is async, you should use `RedisSchtickWrapper.WrapAsync()`.

```csharp
wrapper.WrapAsync(async (task, time) => await DoSomethingAsync());
```

### Get Last Run Event

The `Schtick.AddAsyncTask()` method has an optional `lastKnownRun` parameter which is used in conjunction with the `window` parameter. If you want to specify a window, you can get the last run time from redis first using the `GetLastRunInfo()` or `GetLastRunInfoAsync()` methods.

```csharp
var schtick = new Schtick();
var redis = ConnectionMultiplexer.Connect("localhost:6379");
var wrapper = new RedisSchtickWrapper(() => redis.GetDatabase());

var info = wrapper.GetLastRunInfo("unique-task-name");
schtick.AddAsyncTask("unique-task-name", "hours(*)", wrapper.Wrap((task, timeIntendedToRun) =>
{
	// your callback code here
	
}), lastKnownRun: info.ScheduledTime, window: TimeSpan.FromMinutes(10));
```
